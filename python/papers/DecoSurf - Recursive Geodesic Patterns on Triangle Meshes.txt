DecoSurf: Recursive Geodesic Patterns on Triangle Meshes
DecoSurf : Recursive Geodesic Patterns on Triangle Meshes
GIACOMO NAZZARO, Sapienza University of Rome, Italy
ENRICO PUPPO, University of Genoa, Italy
FABIO PELLACINI, Sapienza University of Rome, Italy
Fig. 1. Models decorated with DecoSurf (large images) to match the style of real-world photographs (upper insets), together with the input meshes (lower
insets: teapot 1.5M triangles, elephant 2M triangles). We model decorations by recursively splitting a surface into progressively finer regions, to which we
apply material and displacement variations. All patterns were constructed with only four operators that split regions along the isolines or integral curves of
scalar fields derived from geodesic computations. Photos of real objects: teapot by Natalya Sots; elephant by Dayal J. Daryanani.
In this paper, we show that many complex patterns, which characterize the
decorative style of many artisanal objects, can be generated by the recursive
application of only four operators. Each operator is derived from tracing the
isolines or the integral curves of geodesics fields generated from selected
seeds on the surface. Based on this formulation, we present an interactive ap-
plication that lets designers model complex recursive patterns directly on the
object surface, without relying on parametrization. We support interaction
on commodity hardware on meshes of a few million triangles, by combining
light data structures together with an efficient approximate graph-based
geodesic solver. We validate our approach by matching decoration styles
from real-world photos, by analyzing the speed and accuracy of our geodesic
solver, and by validating the interface with a user study.
CCS Concepts: • Computing methodologies→ Graphics systems and
interfaces; Shape modeling.
Authors’ addresses: Giacomo Nazzaro, Sapienza University of Rome, Rome, Italy,
nazzaro@di.uniroma1.it; Enrico Puppo, University of Genoa, Genoa, Italy; Fabio Pel-
lacini, Sapienza University of Rome, Rome, Italy.
2020. XXXX-XXXX/2020/7-ART $15.00
https://doi.org/10.1145/nnnnnnn.nnnnnnn
Additional Key Words and Phrases: user interfaces, geometry processing
ACM Reference Format:
Giacomo Nazzaro, Enrico Puppo, and Fabio Pellacini. 2020. DecoSurf : Re-
cursive Geodesic Patterns on Triangle Meshes. 1, 1 (July 2020), 13 pages.
https://doi.org/10.1145/nnnnnnn.nnnnnnn
1 INTRODUCTION
Many artisanal objects are decorated with complex patterns, con-
sisting of simple basic shapes, like dots, lines and circles organized
into nested hierarchies. The complexity of these decorations comes
from repetitive structures that appear handmade instead of being
arranged geometrically. Artisans create such decorative patterns
by recursively splitting regions to add progressively finer details.
Fig. 1 shows examples of these recursive decorative patterns that are
often found in handcrafted Italian ceramics and wood pieces from
Indian art. Note how surfaces are decorated both by changing color
and material, but also by altering the surface locally, e.g., adding or
removing clay in ceramics.
, Vol. 1, No. 1, Article . Publication date: July 2020.
ar
X
iv
:2
00
7.
10
91
8v
1 
 [
cs
.G
R
] 
 2
1 
Ju
l 
20
20
https://doi.org/10.1145/nnnnnnn.nnnnnnn
https://doi.org/10.1145/nnnnnnn.nnnnnnn
2 • Nazzaro, et al.
With the advent of 3D printing and the need for personalization,
digital modeling of recursive decorative patterns becomes important.
Reproducing these patterns with digital sculpting tools may require
hours of work by a skilled artist to decorate a single object. The
alternative would be to use procedural programs, grammars or node
graphs, but such techniques are notoriously hard for non-technical
artists and novices. In the research literature, we are not aware of
any work specifically addressing this class of patterns.
In this paper, we present DecoSurf, a general yet simple frame-
work for modeling recursive decorative patterns. Fig. 1 and Fig. 12
show examples of decorations created with our model that match
real-world styles. We obtain our patterns as recursive applications
of only four generic operations, each of which splits a region of the
surface into smaller regions to generate progressively finer deco-
rations. At each split, we optionally apply material variations and
displacement to define the final look. The key insight of our work
is that a large class of decorative patterns can be modeled by recur-
sively cutting regions along the isolines and the integral curves of
geodesic fields computed from appropriately selected seeds, namely
the regions’ borders or points sampled within each region. To better
integrate our work with designers workflow, we focus on control-
ling pattern generation using an interactive application, rather than
asking artists to write procedural programs or grammars. To reduce
repetitive work though, we also support easy-to-use predefined pro-
cedural patterns that are integrated into the interactive workflow.
We model patterns directly on surfaces, relying on geodesic dis-
tances for three main reasons. First, we want to work directly on the
manifold using its intrinsic metric, thus avoiding distortions, discon-
tinuities and topological artifacts, which arise from parametrization
and require complex handling during pattern synthesis. Second, the
geodesic metric encodes many intrinsic properties of the surface and
remains well defined after mesh split, even when applying displace-
ment. This in turn allows us to define a closed algebra of operators
that can be applied at will recursively to generate a remarkable va-
riety of decoration styles. Finally, having one metric for all patterns
is practical to implement and easier to optimize compared to using
a variety of unrelated operators.
We address surfaces represented with fine triangle meshes, sim-
ilarly to digital sculpting, using roughly a million triangles per
surface to ensure that patterns are finely represented and to model
displacement precisely. The main challenge is thus to support inter-
activity for all operations involved in pattern generation. A key point
of this work is the careful design of our data structures, which allow
us to implement simple algorithms that scale efficiently to highly
tessellated meshes. Our patterns depend on two main operations:
computation of geodesic distance fields and cutting triangle meshes
along isolines and integral curves of these fields. Mesh cutting is
relatively straightforward to implement efficiently, while geodesic
computations are notoriously expensive to perform. To address this
problem we combine data structures with a small footprint together
with a fast, graph-based, approximate, geodesic solver that allows
for dynamic update and scales very well with mesh complexity.
We have implemented a prototype user interface, which exposes
the pattern operators directly. Fig. 8 shows the interface, while the
supplemental video demonstrates the use of each operator and the
creation of a complex decoration. While we focus on interactive
editing, we also show that our operators can be used procedurally.
We validate how well DecoSurf models real-world recursive dec-
orations in three manners. First, we model decorations to match the
styles of real-world artisanal objects. We found that we can replicate
complex patterns from different styles with ease. Second, we mea-
sure the accuracy and speed of our geodesic solver and of the overall
editor to show that we can maintain both accuracy and interactivity
while modeling. Third, we run a user study where we ask subjects
to model complex patterns with our interface and whether those
patterns match real-world surfaces. The main results of the study
are that users can reproduce complex patterns with ease and they
find that our patterns match real-world styles.
In summary, all these results were made possible by a few key
technical contributions:
• the definition of a small set of operators, based on computing
geodesic fields from appropriate seeds, which can be com-
bined recursively to obtain many intricate decorations;
• the implementation of a fast geodesic solver that is interactive
on meshes with millions of triangles, requires no expensive
pre-computation, can be updated efficiently upon mesh edit-
ing, and is accurate enough at high triangle count;
• the implementation of a user interface to generate recursive
decorative patterns that is simple-to-use while allowing the
creation of complex decorations;
• the extension of our model to a procedural use;
• the validation of our model by matching real-world photos,
testing accuracy and speed, and running a user study.
2 RELATED WORK
Procedural Patterns. Complex patterns may be generated with
procedural methods, for which there exists significant literature.
The main differences between procedural algorithms depend on the
domain in which they perform the synthesis, the control given to
designers, and the underlying algorithmic formulation.
Procedural texturing is at the base of most pattern synthesis used
both in the literature and in practice. [12] present the basic methods
for procedural texturing, which are applied commonly in practical
applications. These methods are very general in the patterns that
they define, but they all require the user to describe the pattern
using either code or visual languages, and pattern generation re-
quires evaluating a function at each point in either 2D textures, or
3D volumes. We differ substantially from this approach in that we
generate structured patterns directly on objects’ surfaces instead of
relying on generating textures that would require a parametrization.
Also, recursive patterns cannot be constructed by evaluating a func-
tion on each surface location but they require recursive evaluation
of the entire pattern.
A second class of methods generates new patterns directly from
example images via non-parametric texture synthesis implemented
as variations of constrained random sampling, see [34] for a survey,
or via neural network and generative adversarial networks, e.g., [31,
36]. While these methods are remarkably reliable for unstructured
patterns, they often fail to capture patterns with complex structural
properties. Structured recursive patterns, in particular, cannot be
, Vol. 1, No. 1, Article . Publication date: July 2020.
DecoSurf : Recursive Geodesic Patterns on Triangle Meshes • 3
captured by non-parametric synthesis as shown in [28] for the
simpler 2D case.
The last class of methods, and the one more closely related to our
work, is based on stochastic grammars that recursively split shapes
into smaller components. [28] show that group grammars can be
used to describe tangle patterns in the 2D domain. Group gram-
mars are extensions of shape grammars popularized for modeling
buildings, see [30] for a recent review. Groups grammars have been
extended to procedural animation as motion grammars shown in [6].
[21] uses grammar guided by vector fields to place external details
on surfaces, but cannot handle recursive patterns. An alternative
approach to grammars is to use a custom programming language
to express stationary discrete textures, as shown in [22]. Of these
works, [28] is closest to ours since it also models recursive patterns.
The main differences between the two approaches are that they
use ad-hoc operators only suitable to tangle art in 2D, while we
propose general operators working on 3D surfaces. Also, we focus
on interactive editing, versus building a grammar system. In fact,
our method may be considered a super-set of theirs, while none
of the images in this paper could have been generated using the
formulation in [28].
Geodesics. Broadly speaking, the literature offers three classes
of methods for computing geodesic distance fields and paths over
surface meshes. A survey can be found in [2], although several more
recent methods exist.
Exact methods for polyhedral surfaces stem from the seminal
algorithms presented in [23] and [7], which were improved several
times in the literature. But even the most recent methods in this
line [27] are too slow to support interaction on moderately large
meshes.
Graph-based methods provide approximated solutions of polyhe-
dral geodesics, by restricting possible paths to chains of arcs in a
graph. A straightforward shortest path computation on the network
of edges results in poor distance estimation and wiggly paths. In
[4], such paths are improved by computing shortcuts on-the-fly.
[19, 20] precompute an extended graph adding Steiner nodes on
edges to improve the approximation. Most recent methods in this
class [33, 35] precompute a sub-graph of the complete graph con-
necting all vertices, such that each possible geodesic path can be
approximated well with a sequence of paths in such graph. We rely
on a simple variation of graph-based methods, discussed in Sec. 4.2,
which scales well to large meshes, and can be maintained very easily
and efficiently upon mesh refinement.
PDE methods define the geodesic distance problem in terms of
partial differential equations [8, 17] and provide results that approx-
imate geodesic distances on a smoothed surface. The Fast Marching
Method [17] requires no pre-processing and could be adapted well
to local computations and dynamic mesh refinement, but it is overly
slow for our needs. A parallel version of FMM has been proposed
very recently [3], which greatly improves time performances, yet
remaining slower than our approach, with a comparable accuracy.
The heat method [8] requires resolving sparse linear systems of
the size of the mesh. It can run very efficiently on relatively large
meshes by exploiting pre-factorization, but it cannot be extended
easily to manage local computations, or dynamic mesh refinement.
Fig. 2. Complex recursive patterns are obtained in just eleven steps (left
to right, top to bottom) starting at a base shape (upper left). At each step
we apply a basic operation, which recursively splits the surface into finer
decorations. The generated patterns naturally follow the shape of the surface,
as they are based on geodesic distance fields.
The former issue can be partially addressed by incorporating the
methods proposed in [14, 15].
3 RECURSIVE GEODESIC PATTERNS
We aim at producing patterns defined as recursive subdivisions
of a surface into nested shapes. We show that a small arsenal of
simple operators, defined upon geodesic fields and combined in the
context of a coherent framework, together with the recursive nature
of decorative patterns, is sufficient to generate a great variety of
patterns that match the style of handmade decorations. Fig. 2 shows
an example of a pattern generation sequence.
3.1 Overview
Pattern Representation. Let M be a 2-manifold, possibly with
boundary. A region R is a connected subset of M bounded by a
finite number of oriented boundary loops. A recursive pattern T is
a tree of regions, having its root at M and such that the children
of each region R in T form a partition of R. The leaves of T form a
partition ofM and those regions ultimately define the pattern.
Operators. We construct decorative patterns by recursively apply-
ing a small set of four operators that split an input region into two
or more output regions, by cutting the region with lines or loops.
After each split, each region can be assigned a different material, and
surface displacement can be optionally applied. In our framework,
operators trace lines that are either contour lines of a smooth scalar
field f defined overM, or integral curves of its gradient ∇f .
, Vol. 1, No. 1, Article . Publication date: July 2020.
4 • Nazzaro, et al.
Fig. 3. Example decorations created by applying only one operator with different field and seed sets. (Top, left to right) Contour operator with (1) dist field
from the inner boundary (in blue) cutting along a single isovalue; (2) dist field from the inner boundary with multiple isovalues; (3) blend field between inner
(blue) and outer (orange) boundary, cutting along multiple isovalues; (4) dist field from uniform sampling of points along the inner boundary; (5) dist field
from Poisson sampling of points on the surface; (6) blend field between sampled points (blue) and boundaries (orange). (Bottom left, left to right) Stream
operator with (7) dist field from inner boundary; (8) blend field between inner and outer boundary. (Bottom middle, left to right) Voronoi operator with (9) dist
field from points selected with Poisson sampling; (10) dist field from manually selected points. (Bottom right, left to right) Polyline operator with (11) closed
polyline on a multiply connected region; (12) open polyline connecting two points on the same boundary loop.
Geodesic metric. We define the scalar field f upon geodesic dis-
tances, which depend on both the manifold M, and a seed set S
made of points and lines onM from which distances are computed.
Much flexibility of our operators stems from the possibility to set
seeds in a proper way, e.g., combining lines from the boundary of a
region and points sampled inside a region or on its boundaries.
We consider two types of scalar fields, shown in Fig. 4: the geo-
desic distance distS (x) of surface points x from the seed set S , and
the blend between geodesic distance fields from two independent
seed sets, defined as
blendS,S ′(x) =
distS (x)
distS (x) + distS ′(x)
.
The blend field, already used in [5] to derive parametrizations,
has some nice properties: its values are always in the range [0, 1],
in particular blendS,S ′(S) = 0 and blendS,S ′(S ′) = 1; and it is anti-
symmetric in the sense that blendS,S ′(x) = 1 − blendS ′,S (x). More-
over, if S and S ′ are lines, its contour lines are parallel to both of
them in their vicinity, and the integral curves of its gradient meet
them orthogonally.
di
st
bl
en
d
Fig. 4. Field visualization: dist field from the center and blend field from
center to border.
3.2 Operators
In our framework, we use only four operators, which are summa-
rized in Fig. 3 and described in the following.
Contour operator. The contour operator traces the contour lines
of the geodesic field, either dist or blend. The generated pattern de-
pends on the selected seeds as well as on an isovalued . When applied
to a region, the contour operator generates two or more regions,
splitting the surface with the contour lines at value d . Depending on
the selected seeds and the desired isovalue, this operator can be used
to construct a variety of patterns. For example, when considering the
distance from the region boundary, this operator produces outlines,
while if used with points inside a region it produces polka dots. By
repeating the cuts at different equally spaced isovalues, the operator
generates concentric or parallel stripes, where the density of stripes
is controlled with a parameter. The contour operator has been used
to obtain most of the decorations on the teapot in Fig. 1 and overall
it is the most frequently used operator in all our examples.
Stream operator. The stream operator cuts regions by tracing the
integral curves of the gradient of the geodesic field, either dist or
blend . In this case, the seed sets are comprised of region bound-
aries, S and S ′, from which the integral lines emanate or end. The
generated pattern depends on the selected seeds and the desired
number of lines, whose starting points are sampled uniformly along
seed S . The stream operator generates n stripes, each bounded by
two consecutive integral curves. Such stripes stream outwards S ,
and towards S ′ if the latter is specified. The stream operator has
been used to obtain the main pattern of the rug on the back of the
elephant in Fig. 1, as well as in several parts of the rolling teapot in
Fig. 12. Contour and stream operators can be combined to generate
grid patterns on cylindrical regions. See the example in Fig. 5 and
the paragraph on Grouping and Hierarchy below.
, Vol. 1, No. 1, Article . Publication date: July 2020.
DecoSurf : Recursive Geodesic Patterns on Triangle Meshes • 5
Voronoi operator. The voronoi operator partitions a region into
the cells of a Voronoi diagram in the geodesic metric, each one
corresponding to a point in the seed set. The user controls the seeds
in the region, which can be either manually selected, or generated
with Poisson sampling, as described in Sec. 4.2, to simulate the
look of centroidal Voronoi tessellation. Voronoi diagrams are used
extensively in procedural pattern generation, but their common use
is as a 2D or 3D texture. Our patterns are generated over the surface,
so they have a more natural look. We use the Voronoi operator to
obtain cellular-like patterns and as a drawing scaffold to place finer
details. See examples on the central mask and on the vase to the
right in Fig. 10, as well as on the fertility in Fig. 12.
Polyline operator. Finally, the polyline operator draws a geodesic
polyline on the surface by connecting a sequence of seed points.
The polyline splits a region into two if it is closed or it connects two
points from the same boundary loop. If instead the polyline connects
two different boundary loops, it does not split the region but it is
embedded into the region’s boundary and changes its topological
type. For instance, two such lines can be used to cut a longitudinal
strip from a cylindrical region, e.g., the spout of the teapot in Fig. 1.
The polyline operator is most often used to cut large, meaningful
patches that are then refined and decorated with the other operators.
3.3 Applying Operators
Seed selection. In our prototype, the user can select region bound-
aries, either completely or partially, as well as points on the surface.
A seed set is made of an arbitrary collection of such selections.
Points can be either selected individually, or sampled according to
a Poisson distribution in the geodesic metric. Significantly different
patterns stem from different selection as already shown in Fig. 3.
Grouping and Hierarchy. To further extend the capabilities of our
framework, we support the application of operators not only to the
leaves of T , but also to regions that are higher in the hierarchy. In
this case, the operator defines fields and lines in the whole selected
region, while all sub-regions that are descendant from it are sliced
with such lines, and new leaf regions are generated accordingly.
See examples in Fig. 5 and Fig. 9 (grid). This operation is natural
in our framework, since field computation and split operators are
independent. This same scenario required specialized cutting opera-
tions in the group grammars presented in [28]. This extension also
implies that we are less sensitive to the order in which operations
are applied, a common concern in split grammars [30], thus leaving
more freedom to the user.
Perturbation and displacement. We can perturb geodesic fields and
displace surface points to obtain a more “handcrafted”, organic, look.
Scalar field perturbations simulate the imprecision of artists’ hands;
while surface displacement simulates accumulation or removal of
material. See examples in Fig. 6 and Fig. 7.
To simulate perturbation and handmade imprecisions, we apply
3D Perlin noise to the vertices of the mesh by offsetting their posi-
tion along the normal direction before computing geodesic distances.
This perturbation is just symbolic and used only by the geodesic
solver, while the actual mesh is not changed. Geodesic distances
Fig. 5. (Left) The body of the vase has been partitioned into stripes with a
contour operator. (Middle) A Polka dots pattern is obtained with a contour
operator applied to Poisson point sampling in each stripe region separately.
(Right) The same pattern is applied on the parent region of the stripes, which
is the body of the vase; in this case, the whole surface between the red strips
is considered as a single piece for point sampling and distance computation.
Fig. 6. The same pattern is generated without perturbation, with perturba-
tion of the scalar field and with perturbation applied to the surface before
geodesic field computation. Note how perturbing the surface instead of the
resulting geodesic field preserves the topology of the generated regions, e.g.,
connected components.
Fig. 7. Example pattern generated applying strong surface displacement
using different profiles to create bulges and horn-like structures. Note how
we can coherently edit the horns with additional decorations since distance
fields are computed on the updated geometry.
computed on such warped geometry are therefore transformed ac-
cordingly to a coherent metric and produce irregular shapes, provid-
ing organic results. This works significantly better than perturbing
the scalar field directly, since this can cause unwanted topological
changes to the perturbed regions due to the fact that the perturbed
field is no longer a distance field. Perturbation can be controlled by
setting the gain and frequency of the Perlin noise. For instance, all
the irregular blobs on the body of the teapot in Fig. 1 are actually
circles from a perturbed metric; likewise, the irregular stripe pat-
terns on the spherical bodies forming the lid of the same teapot are
obtained with perturbation. See also supplemental video.
, Vol. 1, No. 1, Article . Publication date: July 2020.
6 • Nazzaro, et al.
Fig. 8. We implemented an application for real-time editing that let the user
decorate an input model applying the operators described in Sec. 3.2 directly.
The user interface also features utilities for all the operations described in
Sec. 3, such as surface displacement, perturbation, macros and procedural
pattern generation.
Finally, we allow the user to apply arbitrarily-large surface dis-
placement, after each operator is applied. The displacement is pro-
portional to the geodesic distance from the region boundaries, being
null at the boundaries to avoid discontinuities. Its profile is con-
trolled by applying gain and bias operators from [29], to create
bumps, pits, ridges or spikes. This feature has been used extensively
in most of our results, see Figures 1, 10 and 12.
3.4 User Interface
To create and edit decorative patterns, we have implemented a
user interface that presents to the user the selection methods and
split operators exactly as described previously. We choose to use a
straightforward mapping of the operators’ types and parameters
to the interface since we found it easy to manipulate them directly,
without further remapping or interface tuning. To further simplify
editing, we support hierarchy tree navigation and undo, respectively
by maintaining the pattern hierarchy and by storing snapshots of
the internal data structures. Fig. 8 shows the user interface that is
also demonstrated in the supplemental video. We have used this
interface to generate all results in this paper.
Macros. Overall we found that by combining selection, operators
and hierarchy we can create very complex patterns with ease. We
also found that some specific combinations of operators and seed
sets were often chosen together to create distinctive and recogniz-
able patterns. To reduce manual work, we bundle these configu-
rations into “macros”, in a manner similar to 3D editors. In our
application, each macro is represented with just a button in the in-
terface. Fig. 9 shows two simple sequences of editing using the eight
macros we found most useful. See figure caption for a description.
Feedback Cycle. Applying an operator always implies first com-
puting a geodesic field and then cutting the surface along its contour
lines or integral curves. We show live previews of the final result
before cutting the mesh, by just coloring the surface with real-time
shaders. This gives immediate, meaningful and precise feedback
Fig. 9. Example decoration created by applying four macros successively.
(First row, left to right): Example decoration applying four macros suc-
cessively. (1) The sunburst macro creates longitudinal stripes or wedges
connecting the two borders of a cylindrical region, by applying the stream
operator and the two boundaries as seed sets. (2) The polka dots macro, in
the blue region, creates dots by applying the contour operator to a set of
Poisson-sampled seed points from the selected region. (3) The frames macro
generates concentric outlines by applying the contour operator recursively
to the boundary of the selected region, that in this case is the white one.
(4) The flower macro creates flowing decorations by applying the contour
operator to the blend between the distance from the region boundaries
and the distance from Poisson-sampled points. (Second row from the left)
Example decoration created by applying four macros successively. (5) The
grid macro generates checkerboards by recursively applying the contour and
stream operators between the opposite boundaries of a cylindrical region.
(6) The outline macro creates outlines by applying the contour operator
to all the boundaries off the selected boundaries. (7) The lace macro cre-
ate embroidery-like decorations by applying the contour operator to seed
points uniformly sampled from the boundaries of the selected region. (8)
The cells macro creates cellular patterns by applying the Voronoi operator
to Poisson-sampled seed points.
before actually modifying the model. In turn, this allows the user to
work non-destructively while seeking good parameter values, and
only commit the edit once it is good.
3.5 Procedural Patterns
The operators described before can also be applied automatically to
generate fully procedural patterns. [28] demonstrate how to gen-
erate 2D recursive patterns using group grammars, a variation of
context-free grammars that can be used to describe stochastic recur-
sive patterns. While our operators and selections are very different
from theirs, the manner in which they can be recursively applied is
similar. Inspired by their work, we have implemented procedural
patterns as described below using a formalism which is equivalent
to a group grammar. In contrast to prior work, we integrate pro-
cedural generation in our interface, where procedural expansion
, Vol. 1, No. 1, Article . Publication date: July 2020.
DecoSurf : Recursive Geodesic Patterns on Triangle Meshes • 7
Fig. 10. Examples of fully procedural decorations created automatically (except colors). Procedural patterns are created by recursively applying macros that
are sampled stochastically. After each expansion, regions are regrouped as in [28], to achieve more structured results. The composabilty of our operators
guarantees that procedural generation is always robust and can be applied at any point of the editing session.
can be applied to any region by just clicking a button. The resulting
pattern can then be non-destructively edited interactively. The user
controls procedural generation just by selecting the region to edit,
unlike [28] that require users to edit grammars directly. We follow
a simpler approach since we focus on interactive editing and not
grammar definitions, which are notoriously hard to edit, especially
for designers. The resulting generator is equivalent to one example
instance of group grammars, demonstrating that our operators and
selections can also be controlled procedurally if desired.
Procedural Generation. We generate procedural patterns by recur-
sively applying macros with default parameters to the leaf regions of
the pattern tree. For each region, the macro to be applied is sampled
stochastically, with a probability that depends on specific attributes
of the region. Region attributes describe its overall shape as well
as the way it was generated, and determine which macro would
probably generate a pleasing result. The selection tags and probabil-
ities used for our patterns are included in the supplemental material.
Here we describe the features we use to derive them.
For each region, we keep track of its boundary loops and corners,
namely the intersection points where three or more regions meet.
For example, a region with one boundary and four corners will
likely produce pleasing grid patterns. This is akin to [28] where
they instead track directionality of shapes, which is hard to do on
surfaces since absolute tangent directions cannot be defined in a
coherent manner.
As in group grammars, each region is assigned a type tag de-
pending on the kind of operation that generated it and the number
of region corners. For example, after an outline, we differentiate
regions between the inside and the border band, and after dots, we
differentiate the circle-shaped regions from the background. After
each expansion, regions are grouped with the same rules used in
[28], so that the same macro is then applied to each region of a
group, to obtain more structured results. Some examples of such
rules are to group regions by type, by attributes or with a cyclic
rule to obtain alternating or checked patterns. Procedural displace-
ment is applied uniformly after the expansion is complete, while
the choice of colors and materials is left to the user.
Discussion. Fig. 10 shows example patterns generated procedu-
rally. These examples show that operators and selections can be
controlled procedurally. The main reason is that the operators can
be applied to most regions independently of the region shape, i.e.
they are closed under composition. This means that we can apply
them recursively at will, which in turn implies that we can use many
procedural formulations introduced by prior work to control the
generation of procedurals recursive details directly on surfaces.
4 IMPLEMENTATION
In the discrete setting we encode the manifold M as a finely tes-
sellated triangle mesh M . We refine the mesh after applying each
operator to precisely embed region boundaries as chains of edges,
allowing us to represent regions exactly as groups of triangles. Since
we target design applications, we support real-time interaction on
commodity hardware on meshes up to a few million triangles.
Our implementation relies on geodesic distance fields, which are
notoriously expensive to compute, especially for large meshes. We
use a simple graph-based geodesic solver that is efficient, scalable,
accurate enough at our tessellation level, and easy to update as the
mesh is refined and displaced. We achieve efficiency and scalability
by encoding the mesh and the graph with compact and tightly
coupled data structures. This data-oriented design has other benefits
since it easily supports undos, serialization and rendering; we will
not discuss these aspects in this paper, though.
In the remainder of this section, we discuss implementation de-
tails to aid in reproducibility. We will also release an open-source
implementation upon paper acceptance.
4.1 Representation
Mesh data structure. We encode triangle meshes with an indexed
data structure augmented with face adjacencies, a.k.a. winged data
structure [26], compactly stored in three arrays: positions (float[3]),
triangles (int[3]), and face adjacencies (int[3]). The indexed for-
mat provides aminimal representation of geometry and connectivity,
while adjacencies provide support for efficient line tracing, region
flooding and boundary computation.
Pattern representation. Our patterns partition the surface into
regions. We represent regions implicitly by labeling each triangle
with the identifier of the region containing it. Hence, the collection
of patterns covering the mesh is represented as an array of integers,
, Vol. 1, No. 1, Article . Publication date: July 2020.
8 • Nazzaro, et al.
A B C D
Fig. 11. (A) Our graph has one node for each vertex in the mesh (black dots),
a bidirectional arc for each edge in the mesh (black lines) and for each pair
of vertices that are opposite to an edge (red lines). The weight of each arc is
equal to the geodesic distance between the connected vertices. (B) When
an operator is applied, the surface is partitioned into new regions (blue and
grey). The boundary that separates the new regions is a polyline crossing
the edges of the triangles in the mesh. (C) The mesh is refined to embed
the polyline, so that each triangle belongs to one region. (D) Only arcs in
the graph traversing the split triangles are updated.
one for each triangle. We maintain the hierarchy of region tags in a
tree data structure, with a negligible space overhead, as it contains
at most few thousands nodes even on our most complex results, as
shown in Fig. 13. Compared to storing a hierarchy of meshes, this
separate representation is both significantly more compact and does
not need to be updated as the mesh is refined.
Field representation. Scalar fields are encoded at mesh vertices
and extended by linear interpolation, while their gradient field is
piecewise-constant on triangles. Operators compute either contour
lines or integral curves, including geodesic paths, which cut the
mesh along polylines. We split all triangles intersected by such
polylines every time an operator is applied, so that regions always
consist of discrete collections of triangles.
4.2 Geodesic Computations
Geodesic Graph. Our solver is implemented using the graph ex-
emplified in Fig. 11. Nodes correspond to mesh vertices, while arcs
correspond to mesh edges as well as dual edges, i.e., arcs connecting
pairs of vertices opposite to an edge. The length of each arc is com-
puted as the exact geodesic distance between the vertices it connects.
Arc lengths are stored in single precision to reduce memory usage,
as our method is not prone to high error propagation – distances are
just summed during graph visit – while most approximation error
stems from discretizing geodesic paths along arcs of the graph.
We store the graph as adjacency lists with a simple array of arrays
data structure, where we employ small vector optimizations for the
adjacency lists. This solution ensures that most of the graph is
laid-out on a single contiguous chunk of data, which reduces heap
pressure and improves cache locality during the graph visit.
We build the graph once at the beginning of the editing session,
by using face adjacencies to construct dual edges, as shown in
the supplemental pseudocode. Then we locally update the graph
after each mesh refinement operation: updates only involve nodes
incident at split triangles, which are retrieved easily and efficiently,
thanks to the implicit connection between vertices and nodes, and
edges/adjacencies and arcs. Updates upon displacement are also
efficient since they only require recomputing edge lengths, without
modifying the graph topology.
Geodesic Solve. We compute geodesic distance fields by wavefront
expansion over the graph, shown as pseudocode in supplemental.
We adopt the small-label-first (SLF) and large-label-last (LLL) heuris-
tics [1], which do not require a priority queue. These techniques
perform significantly faster than classical Dijkstra search on this
kind of graphs [33]. Our implementation aggressively exploits com-
putation locality, by applying early exits when bounding the graph
search to a region. The general solver computes distance fields from
any given set of vertices. Seed sets corresponding to lines are just
sampled at their vertices. Note that we use our solver just to com-
pute the geodesic distance, while we do not trace geodesic paths
with sequences of arcs in the graph, as the latter would result in
wiggly polylines.
Poisson sampling. We use Poisson sampling to generate seed sets
for various operators. We adopt a farthest point sampling technique
[13] under the geodesic metric. This scheme requires the computa-
tion of a distance field for each sampling point, which may become
expensive as many points are sampled over large regions. We take
advantage of the wavefront nature of graph search to significantly
optimize the computation time.
We begin by computing the distance field from the region bound-
ary. Then we iteratively select the vertex with maximum distance
and add it to the seed set, and we update the distance field by ex-
panding from the new seed, without resetting the already computed
distances. This allows us to update the distance field only in the
proximity of the new seed, by exploiting early exit when hitting
nodes that already have a shorter distance from the previous set.
The search radius becomes increasingly smaller as points are added
to the seed set, resulting in a significant speedup. See statistics in the
supplemental material. This is another advantage of a graph-based
solver over alternatives that are non-local.
Line tracing. Operators require extracting contour lines and inte-
gral curves, as well as cutting themeshwith such lines. Contour lines
are extracted per triangle by linear interpolation. Integral curves
and geodesic paths are computed by tracing the piecewise-constant
gradient per triangle. Each triangle intersected by one such line is
split along the corresponding segment, forming three new triangles.
When a triangle is split, arcs and nodes are added to the graph to
represent new vertices and edges, and the adjacency of nodes in the
split triangle is updated accordingly, as shown in Fig. 11.
Operators. The operators described in Sec. 3 are implemented
on top of the functionality described before. The contour operator
requires one or two geodesic solves, for dist and blend respectively,
followed by the extraction of isolines and cuts along them. The
stream operator requires the same solves, this time followed by cuts
along integral curves. In both cases, computation is bound to the
region in which the operator is applied.
The polyline operator is implemented by tracing geodesic paths
between each pair of successive points. Each segment is computed
starting at a vertex and ascending the gradient of the distance field
generated from the previous vertex. This operation requires one
solve per segment: early exit occurs as soon as the target vertex is
reached, so computation is bound to the intersection between the
selected region and a geodesic circle having the segment as radius.
, Vol. 1, No. 1, Article . Publication date: July 2020.
DecoSurf : Recursive Geodesic Patterns on Triangle Meshes • 9
The Voronoi operator requires a solve for each element in the
seed set, which may become expensive for large seed sets. We again
optimize this operator by exploiting early exits in graph search. We
first compute the distance field from all seeds together to find its
maximum value. We then set this distance as bound for early exit
when computing the field for each seed. Intuitively, this ensures
that each mesh vertex is visited roughly twice, so computation time
is bounded regardless of the number of seeds. For each vertex of the
region of interest, we collect the distance from its three closest seeds.
Then we generate the Voronoi diagram by splitting all triangles that
have vertices lying in different Voronoi regions, as in [16]. See
statistics in the supplemental material for time performance.
Finally, shape perturbation and displacement are trivially imple-
mented by updating the edge lengths in the graph, and the positions
of vertices, respectively.
Discussion. Our system is very compact and coherent, because
all operations rely on geodesic distance computation, as well as on
few other straightforward operations: line tracing and mesh cutting.
Performance depends on our capability to make geodesic computa-
tions fast, and update our data structures efficiently. In this sense,
the choice of our specific graph solver provides an optimal tradeoff
under a variety of aspects, such as accuracy, speed, scalability, sim-
plicity, dynamic update, and early exits. Scalability, simplicity and
ease of update descend from using just the vertices of the mesh as
nodes, and relations from local mesh topology as arcs. Nodes in our
graph have average degree of 12, hence for a mesh with N vertices
our graph has N nodes and about 6N bidirectional arcs.
In contrast, graph-based methods using Steiner nodes [19, 20]
are much more complex to maintain upon dynamic updates, and
have a larger memory footprint. Their number of arcs increases
quadratically with the number k of Steiner nodes per edge: for
k = 1 there are ∼4N nodes and ∼18N arcs; while, for k = 3, the
count raises to ∼10N nodes and ∼84N arcs, making these graphs
impractical for large meshes even with moderately low values of k .
The DGG [33] and SVG [35] methods use graphs that do have
just the vertices as nodes, but each node has a high degree (order
102 − 103). Their memory footprint is high and they are slow to
update upon mesh refinement. Finally, the method proposed in [4]
relies just on the graph of edges, but computations to straighten
paths are done on-the-fly, making the method suitable for point-to-
point path computation only.
With the PDE method of [8], each solve implies the solution of a
sparse N ×N linear system, which can be pre-factorized for a given
mesh, making the solution fast at the price of pre-computation. The
main concern in using this method is that every time we change the
mesh topology or geometry the expensive factorization step needs
to be repeated. See Sec. 5.2 for a comparative analysis in terms of
accuracy and performance.
5 RESULTS AND VALIDATION
We validated our pattern model in three manners. First, we modeled
decorations that match real-world styles. Second, we tested the
accuracy and speed of the overall system and of the geodesic solver
to show that it remains interactive. Third, we validated our user
interface with a user study to show that novices to the system can
replicate given patterns.
5.1 Editing Sequences
Fig. 1 and Fig. 12 show complex patterns created with our system
during interactive sessions. We chose to model patterns from real-
world examples with different artistic styles to show that our model
can capture intricate decorations made by artisans. Fig. 13 shows
statistics of the editing sequences corresponding to such images.
Overall we found that creating complex patterns is easy with
our interface. We used from up to hundreds of single operations to
create patterns made of up to 1800 individual decorations, which
correspond to regions in our model. Note that some such opera-
tions were applied as macros or procedurals, simplifying editing
further. The number of operations we employ is significantly smaller
than using standard modeling tools with either polygonal modeling
or sculpting workflows, e.g. see [10, 11] for statistics of common
modeling sequences.
To gain a better sense of the recursive nature of the decorations,
we report the depth of the pattern tree, which reached 21 in our most
intricate result. This shows that by applying patterns recursively,
even just a few times, we can greatly increase the complexity of the
decoration while maintaining the editing manageable for users.
5.2 Performance and Accuracy
In our examples, we handle models between 500k and 2M triangles,
which are further subdivided during editing. Throughout the mod-
eling sequences, our system remains interactive with computation
times of about 0.2s per operation, including geodesic computation,
mesh cutting and graph update. Memory usage is also compact,
never exceeding 300Mb, which includes the mesh and the geodesic
solver, as well as interface support data. Performances were eval-
uated on a 2.9 GHz laptop with 16 GB of RAM running with a
single-core for our application.
Fast geodesic computation is the main technical feature that en-
ables us to model decorations well. We test the performance and
accuracy of our solver by computing the geodesic field from a single
source to all vertices on a variety of meshes, summarized in Fig. 14.
While we use a very simple graph, our solver remains accurate
enough with an error between 1.1% and 1.6% over a state of the art
solver for exact polyhedral geodesics [27]. Computation times are
between 0.015s and 0.446s for a single core implementation run-
ning on meshes between 300k and 7.2M triangles. This speed is fast
enough for all our modeling needs.
We compared our solver to a popular, approximate, geodesic
solver based on PDEs [8] using the author’s implementation. The
accuracy of our solver is just slightly lower on relatively small
meshes, while getting better on large meshes. On the other hand,
our solver consistently runs at roughly twice the speed, always
remaining compatible with interaction, even when considering the
additional times for update after mesh cutting.
In terms of pre-computation times, where [8] factorize a sparse
matrix, while we build a graph, our method runs roughly between
10 and 35 times faster. Although pre-computation is just performed
, Vol. 1, No. 1, Article . Publication date: July 2020.
10 • Nazzaro, et al.
Fig. 12. Results created with our application starting from undecorated models, shown in the insets. Decorations were inspired by real world examples: the
tank-teapot on the left reproduces the playful look of handmade toys, the result in the middle matches the appearance of carnival masks of Venice, the statue
on the right is decorated with intricate patterns that imitate tangles on ceramics. Statistics about the models and the editing sessions are reported in Fig. 13
model triangles triangles number of number of tree average time memory
name at start at end regions operations depth per operation usage at end
fertility 0.50M 0.90M 1810 655 21 0.134s 96Mb
teapot 1.50M 1.65M 511 129 13 0.146s 173Mb
tank 1.45M 1.68M 636 145 10 0.189s 174Mb
mask 2.00M 2.15M 62 30 5 0.232s 228Mb
elephant 2.00M 2.61M 364 212 13 0.241s 278Mb
Fig. 13. Statistics on the editing sequences used for interactive decoration. The average time per operation takes into account the time needed to compute the
geodesic field, cut the mesh, update the graph and the pattern representation data.
model [27] [8] ours
name triangles solve build solve error build solve error update
kitten 300k 3.0s 1.49s 0.068s 0.5% 0.061s (24x) 0.015s (4.5x) 1.1% 0.013s
elephant 500k 10.9s 3.47s 0.095s 0.5% 0.098s (35x) 0.027s (3.5x) 1.1% 0.023s
fertility 500k 3.5s 2.86s 0.123s 0.5% 0.109s (26x) 0.026s (4.8x) 1.1% 0.023s
lucy 525k 9.1s 1.98s 0.082s 1.5% 0.175s (11x) 0.034s (2.4x) 1.6% 0.025s
mask 2.0M 121.0s 14.4s 0.391s 1.1% 0.585s (24x) 0.114s (3.4x) 1.2% 0.115s
nefertiti 2.0M 20.3s 14.8s 0.345s 0.9% 0.730s (20x) 0.149s (2.3x) 1.5% 0.139s
dragon 7.2M 79.9s 59.6s 1.500s 3.0% 2.613s (24x) 0.446s (3.9x) 1.5% 0.571s
Fig. 14. Comparison between our geodesic solver, and the solver from [8]. For the latter we use the implementation provided by the author, using Cholmod as
backend. Columns build report pre-processing times to pre-factor the system and to build the graph, respectively. Build times for our solver also include the
time to compute the triangle adjacency needed to build the graph. Columns solve report average time for computing the distance field from a single point
source, where average is taken over 100 random samples. Column update reports the average time to update our graph after mesh split, where average is taken
over 100 different long slices that roughly cut the mesh in half. Root-mean-square errors are computed with respect to the exact polyhedral solution from [27].
once, the high times of [8] suggest that it would be hard to try a
dynamic update after mesh edit.
We also compared our solver to a straightforward implementation
of Lanthier’s graph [20] with just one Steiner point per edge, using
the same graph traversal algorithm. In terms of accuracy, results
are comparable to our solver. We cannot objectively compare solve
times as the two implementations were not equally optimized, but
on average our solver was about 10 times faster. Regardless of low-
level optimizations, we assume our method to be more efficient,
as the Lanthier’s graph with one Steiner node per edge is more
than three times larger, as explained in Sec. 4.2. Beyond accuracy
and performance, our graph is much easier to maintain upon mesh
cutting, and that was the determining factor, which made it a better
choice for our application.
, Vol. 1, No. 1, Article . Publication date: July 2020.
DecoSurf : Recursive Geodesic Patterns on Triangle Meshes • 11
Wewish to remark that the choice of a geodesic solver is relatively
orthogonal to our pattern model, though.
5.3 User Study
We ran a user study to validate whether our prototype system is
easy to use, whether it allows users to model complex patterns, and
whether the style of the models we produce matches the style found
in handmade artisanal objects.
Experimental procedure. We asked 17 subjects with different de-
grees of expertise, ranging from novices to professional 3D artists,
to use our prototype after a short training and an unguided editing
session on a model of their choice. We asked subjects to perform
three matching tasks of increasing difficulty, in which they had to
use the application to reproduce a target image shown in a picture.
Images are provided in the additional material and in Fig. 15.
After each task, subjects were asked to rate the similarity of their
result with the reference and to evaluate how easy they found it to
complete the task, using a scale from 1 to 10. We also asked subjects
to rate whether they would have been able to obtain the same
kind of results with a different 3D application, whether they found
the interface responsive, and whether they were satisfied with the
overall experience. Finally, we have shown to the subjects the teapot
and the elephant decorated models from Fig. 1, and asked them to
recognize whether the style of the image matches real photographs
of similar styles, compared to other alternatives. We include a copy
of the final questionnaire in the supplemental material.
Quantitative Evaluation. Fig. 15 shows the results of our user
study, where for all ratings we rejected the null hypothesis (p ≤
0.05), i.e. those results are statistically significant.
All 17 users were able to successfully complete the reproduction
tasks, spending different amounts of time in the editing session, but
never more than 4 minutes for each task, out of a maximum task
length of 5 minutes. All users rated their results quite similar, if
not identical, to the reference ones. This suggests that our interface
provides sufficient control to reproduce given complex patterns. All
subjects also found the tasks easy to perform, and reported that
they would not have been able to obtain the same kind of results
with a different 3D editing software.
In general, all subjects also found the interface responsive and
were satisfied with the overall experience with the application, con-
firming that our implementation remains interactive at all times.
All subjects but one correctly recognized the style from which our
results were inspired, meaning that the models produced by our
application match the look of real hand-crafted objects.
In conclusion, the user study demonstrated that users agree that
our application is expressive, easy to use, and can produce results
that match the look of real decorated objects.
Qualitative Feedback. Some non-expert users informally reported
that they were surprised by the complexity of the results they man-
aged to obtain with the application and the ease with which they
were able to control the editing operations. We think that this can-
not be explained only by the usability of the interface, but rather
it is a direct consequence of the intuitive design of our editing op-
erators, which requires no expertise to be understood. These facts
Fig. 15. Result data from the user study. Histograms on the left report the
time spent by the subjects to complete each task. The bar chart just below
shows that all subjects but one correctly recognized the real world styles
from which our results in Fig. 1 were inspired. The remaining bar charts
show subjects’ feedback about their tasks: users with different amount
of expertise found the tasks easy to perform, their results similar to the
reference ones and the application responsive. All subjects were satisfied
with their editing experience with the application and do not think that
using another digital tool would allow them to obtain the same results in
the same time.
suggest that the editing workflow of our application is well-suited
for non-technical artists and designers, too.
Experts users reported that they found the application responsive
and pleasant to use. We quote here some informal feedback we
collected: “The editing was surprisingly fast and enjoyable. I did not
have to think about triangles, edge loops or topology issues as in
Maya or Blender; I could just focus on the result.”
, Vol. 1, No. 1, Article . Publication date: July 2020.
12 • Nazzaro, et al.
5.4 Limitations
Patterns. While we introduce a general pattern model, recursive
patterns based on tight packing of arbitrarily-shaped elements can-
not be easily reproduced in terms of geodesics. While there is a large
literature on this, we remind the reader that packing is NP-hard
in general, so all methods proposed so far are necessarily strong
approximations.
Another type of pattern that we did not specifically include is flo-
ral decorations. One possibility would be to adapt a region-growing
model similar to the one used in procedural trees and express it in
terms of geodesic paths. The main concern though is that control-
ling floral arrangement over an arbitrary manifold remains hard
since there is no global orientation to use while growing. We leave
the investigation of such further patterns to future work.
Discretization. We rely on fine tesselations to represent decora-
tions and discretize geodesic computation. Using too few triangles
may introduce artifacts, such as wiggly polylines, due to mesh dis-
cretization, graph-based evaluation of distance fields and piecewise-
constant approximation of gradient fields. While we did not witness
these problems in our tests, they are nonetheless possible. An al-
ternative would be to separate the modeling and rendering phases.
Since all our decorations can be encoded as operations on the man-
ifold and its sub-regions, final patterns can be regenerated before
rendering. This would allow us to use an accurate representation of
the manifold, such as a more refined mesh or a subdivision surface,
more accurate geodesy, such as exact methods for meshes or PDE
methods for subdivision surfaces [9], and more accurate methods
for isoline extraction and vector field tracing [18, 24].
6 CONCLUDING REMARKS
We have presented an interactive method for generating recursive
patterns on surfaces and its use to model real-world decorations.
Our model consists of a closed algebra of regions, which can be
split by applying four operators at will. Operators are defined upon
geodesic fields on the surface and our implementation relies on
fast geodesic computations. A user study shows that the resulting
application is effective, it is responsive on meshes in the order of
one or a few million triangles, and it is easy to use for novices too.
Our system is easily extensible in a variety of ways. Directional
fields [32] can be used to generate patterns based on further stream-
lines, which can be easily combed and constrained to lines and
boundaries in the decor. Fields can be also used to locally param-
etrize patches of the surface, thus allowing for a mixed use of our
vector graphics together with raster graphics, i.e. textures, to create
a composite decor. Diffusion curves [25] can be naturally incorpo-
rated too, to support smooth-shaded coloring of regions.
REFERENCES
[1] Dimitri P. Bertsekas. 1998. Network optimization: continuous and discrete models.
Athena Scientific.
[2] Prosenjit Bose, Anil Maheshwari, Chang Shu, and Stefanie Wuhrer. 2011. A
Survey of Geodesic Paths on 3D Surfaces. Comput. Geom. Theory Appl. 44, 9
(2011), 486–498.
[3] Luciano A. Romero Calla, Lizeth J. Fuentes Perez, and Anselmo A. Montenegro.
2019. A minimalistic approach for fast computation of geodesic distances on
triangular meshes. Computers & Graphics 84 (2019), 77 – 92.
[4] Marcel Campen,MartinHeistermann, and Leif Kobbelt. 2013. Practical Anisotropic
Geodesy. In Proc. Symposium on Geometry Processing. 63–71.
[5] Marcel Campen and Leif Kobbelt. 2011. Walking On BrokenMesh: Defect-Tolerant
Geodesic Distances and Parameterizations. Eurographics 30 (2011). Issue 2.
[6] Edoardo Carra, Christian Santoni, and Fabio Pellacini. 2019. Grammar-based
procedural animations for motion graphics. Computers & Graphics 78 (2019),
97–107.
[7] Jindong Chen and Yijie Han. 1990. Shortest Paths on a Polyhedron. In Proc.
Symposium on Computational Geometry (SCG ’90). 360–369.
[8] Keenan Crane, Clarisse Weischedel, and Max Wardetzky. 2013. Geodesics in heat:
A new approach to computing distance based on heat flow. ACM Trans. Graph.
32, 5 (2013).
[9] Fernando De Goes, Mathieu Desbrun, Mark Meyer, and Tony DeRose. 2016. Sub-
division exterior calculus for geometry processing. ACM Trans. Graph. 35, 4
(2016).
[10] Jonathan D. Denning, William B. Kerr, and Fabio Pellacini. 2011. MeshFlow:
Interactive Visualization of Mesh Construction Sequences. ACM Trans. Graph. 30,
4 (2011).
[11] Jonathan D. Denning, Valentina Tibaldo, and Fabio Pellacini. 2015. 3DFlow:
Continuous Summarization of Mesh Editing Workflows. ACM Trans. Graph. 34, 4
(2015).
[12] David Ebert, Kenton Musgrave, Darwyn Peachey, Ken Perlin, and Steve Worley.
2002. Texturing and Modeling: A Procedural Approach (3 ed.). Morgan Kaufmann.
[13] Y. Eldar, M. Lindenbaum, M. Porat, and Y. Y. Zeevi. 1997. The Farthest Point
Strategy for Progressive Image Sampling. Trans. Img. Proc. 6, 9 (1997).
[14] Philipp Herholz and Marc Alexa. 2018. Factor once: Reusing cholesky factoriza-
tions on sub-meshes. ACM Trans. Graph. 37 (2018).
[15] Philipp Herholz, Timothy A. Davis, and Marc Alexa. 2017. Localized Solutions of
Sparse Linear Systems for Geometry Processing. ACM Trans. Graph. 36, 6 (2017).
[16] Philipp Herholz, Felix Haase, and Marc Alexa. 2017. Diffusion diagrams: Voronoi
cells and centroids from diffusion. In Computer Graphics Forum, Vol. 36. Wiley
Online Library, 163–175.
[17] R. Kimmel and J. A. Sethian. 1998. Computing Geodesic Paths on Manifolds. In
Proc. Natl. Acad. Sci. USA. 8431–8435.
[18] Peter Kipfer, Frank Reck, and Günther Greiner. 2003. Local exact particle tracing
on unstructured grids. Computer Graphics Forum 22 (2003), 133–142.
[19] Mark Lanthier, Anil Maheshwari, and Jörg-Rüdiger Sack. 1997. Approximating
weighted shortest paths on polyhedral surfaces. In Proc. of ACM Symposium on
Computational Geometry.
[20] Mark Lanthier, Anil Maheshwari, and Jörg-Rüdiger Sack. 2001. Approximating
shortest paths on weighted polyhedral surfaces. Algorithmica 30, 4 (2001), 527–
562.
[21] Yuanyuan Li, Fan Bao, Eugene Zhang, Yoshihiro Kobayashi, and Peter Wonka.
2011. Geometry Synthesis on Surfaces Using Field-Guided Shape Grammars. IEEE
Trans. Visualization and Computer Graphics 17, 2 (2011).
[22] Hugo Loi, ThomasHurtut, Romain Vergne, and Joelle Thollot. 2017. Programmable
2D Arrangements for Element Texture Design. ACM Trans. Graph. 36, 3 (2017).
[23] Joseph S. B. Mitchell, David M. Mount, and Christos H. Papadimitriou. 1987. The
Discrete Geodesic Problem. SIAM J. Comput. 16, 4 (Aug. 1987), 647–668.
[24] G. M. Nielson and Il-Hong Jung. 1999. Tools for computing tangent curves for
linearly varying vector fields over tetrahedral domains. IEEE Trans. Visualization
and Computer Graphics 5, 4 (1999), 360–372.
[25] Alexandrina Orzan, Adrien Bousseau, Holger Winnemöller, Pascal Barla, Joëlle
Thollot, and David Salesin. 2008. Diffusion Curves: A Vector Representation for
Smooth-shaded Images. ACM Trans. Graph. 27, 3 (Aug. 2008), 92:1–92:8.
[26] A. Paoluzzi, F. Bernardini, C. Cattani, and V. Ferrucci. 1993. Dimension-
Independent Modeling with Simplicial Complexes. ACM Trans. Graph. 12, 1
(1993), 56–102.
[27] Yipeng Qin, Xiaoguang Han, Hongchuan Yu, Yizhou Yu, and Jianjun Zhang.
2016. Fast and Exact Discrete Geodesic Computation Based on Triangle-oriented
Wavefront Propagation. ACM Trans. Graph. 35, 4 (2016), 125:1–125:13.
[28] Christian Santoni and Fabio Pellacini. 2016. gTangle: A Grammar for the Proce-
dural Generation of Tangle Patterns. ACM Trans. Graph. 35, 6 (2016).
[29] Christophe Schlick. 1994. Fast Alternatives to Perlin’s Bias and Gain Functions.
Graphics Gems IV (1994).
[30] Michael Schwarz and Peter Wonka. 2015. Practical Grammar-based Procedural
Modeling of Architecture. In SIGGRAPH Asia 2015 Courses.
[31] Omry Sendik and Daniel Cohen-Or. 2017. Deep Correlations for Texture Synthesis.
ACM Trans. Graph. 36, 4, Article 105b (July 2017).
[32] Amir Vaxman, Marcel Campen, Olga Diamanti, David Bommes, Klaus Hilde-
brandt, Mirela Ben-Chen Technion, and Daniele Panozzo. 2017. Directional Field
Synthesis, Design, and Processing. In ACM SIGGRAPH 2017 Courses.
[33] XiaoningWang, Zheng Fang, JiajunWu, Shi-Qing Xin, and Ying He. 2017. Discrete
Geodesic Graph (DGG) for Computing Geodesic Distances on Polyhedral Surfaces.
Comput. Aided Geom. Des. 52, C (2017), 262–284.
, Vol. 1, No. 1, Article . Publication date: July 2020.
DecoSurf : Recursive Geodesic Patterns on Triangle Meshes • 13
[34] Li-Yi Wei, Sylvain Lefebvre, Vivek Kwatra, and Greg Turk. 2009. State of the Art
in Example-based Texture Synthesis. In Eurographics State of the Art Report.
[35] Xiang Ying, Xiaoning Wang, and Ying He. 2013. Saddle Vertex Graph (SVG): A
Novel Solution to the Discrete Geodesic Problem. ACM Trans. Graph. 32, 6 (2013).
[36] Yang Zhou, Zhen Zhu, Xiang Bai, Dani Lischinski, Daniel Cohen-Or, and Hui
Huang. 2018. Non-stationary Texture Synthesis by Adversarial Expansion. ACM
Trans. Graph. 37, 4 (2018).
, Vol. 1, No. 1, Article . Publication date: July 2020.
	Abstract
	1 Introduction
	2 Related work
	3 Recursive Geodesic Patterns
	3.1 Overview
	3.2 Operators
	3.3 Applying Operators
	3.4 User Interface
	3.5 Procedural Patterns
	4 Implementation
	4.1 Representation
	4.2 Geodesic Computations
	5 Results and Validation
	5.1 Editing Sequences
	5.2 Performance and Accuracy
	5.3 User Study
	5.4 Limitations
	6 Concluding remarks
	References